import com.google.gson.Gson
import groovy.transform.ToString
import net.lingala.zip4j.core.ZipFile

import java.util.Optional as Optionals
import java.util.stream.Collectors

import static SpongePlugin.MINECRAFT_HOME
import static SpongePlugin.PS
import static SpongePlugin.GSON

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.google.code.gson:gson:2.5'
        classpath 'com.google.inject:guice:3.0'
        classpath 'net.lingala.zip4j:zip4j:1.3.2'
    }
}

apply plugin: SpongePlugin

class SpongePlugin implements Plugin<Project> {
    static final Gson GSON = new Gson()
    static final OS PLATFORM = OS.detect()
    static final String PS = File.separator
    static final File MINECRAFT_HOME
    static {
        def home = System.getProperty('user.home')
        switch (PLATFORM) {
            case OS.LINUX:
                MINECRAFT_HOME = new File(home, '.minecraft')
                break;
            case OS.OSX:
                MINECRAFT_HOME = new File(home, '/Library/Application Support/minecraft')
                break
            case OS.WINDOWS:
                MINECRAFT_HOME = new File(home, 'Application Data\\.minecraft')
        }
    }

    void apply(Project project) {
        project.extensions.create('spongestarter', SpongeExtension)

        /** Start the forge client */
        project.tasks.create('startForgeClient', SpongeForgeClient)
    }
}

class SpongeExtension {}

/** Sponge starter runs the needed things to start a sponge instance */
class SpongeForgeClient extends DefaultTask {

    @TaskAction
    def startForgeClient() {
        // Ensure user has a copy of Minecraft
        if (!MINECRAFT_HOME.exists()) {
            throw new Throwable('''
                Minecraft path does not exists, you MUST have a copy of Minecraft, you can grab it from here;
                https://minecraft.net/
            ''')
        }

        File versions = new File(MINECRAFT_HOME, 'versions')
        Optionals<File> forge = Arrays.asList(versions.listFiles()).stream()
                .filter({file -> file.name.contains('forge')})
                .sorted().sorted(Comparator.reverseOrder())
                .findFirst()

        // Ensure user has a copy of MinecraftForge
        if (!forge.isPresent()) {
            throw new Throwable('''
                You do not have forge please install forge, you can grab it from here;
                http://files.minecraftforge.net/
            ''')
        }

        MinecraftVersion version = makeMCVersion forge.get()
        ClassPaths classPaths = generateLibs version;
        classPaths.libs.get().add('versions' + PS + version.inheritsFrom + PS + version.inheritsFrom + '.jar')
        def classpath = classPaths.libs.get().stream().collect(Collectors.joining(File.pathSeparator))
        extractJars classPaths.natives.get(), new File(MINECRAFT_HOME, 'natives')
        String[] args = minecraftArguments(version, classpath, 'Player', ' ', '')
        new ProcessBuilder().with {
            command(args)
            directory(MINECRAFT_HOME)
            inheritIO()
            start().waitFor()
        }
    }

    /** Create a string array of the arguments including var filtering */
    private List<String> minecraftArguments(MinecraftVersion version, String classpath, String... login) {
        Objects.requireNonNull(version)
        String[] argParts = version.minecraftArguments.split(' ')
        def minecraftArgs = [
            'java',
            '-Djava.library.path=natives/',
            // todo launcher java args
            '-cp',
            classpath,
            version.mainClass
        ]
        def varMap = [
            assets_index_name: version.assets,
            version_name: version.id,
            game_directory: MINECRAFT_HOME.toString(),
            assets_root: 'assets/',
            version_type: version.type,
            user_type: 'mojang',
            user_properties: '{}',
            auth_player_name: login[0],
            auth_access_token: login[1],
            auth_uuid: login[2]
        ]

        argParts.each {
            if (it.startsWith('${') && it.endsWith('}')) {
                def var = it.substring(2, it.size() - 1)
                if (varMap[var] == null || varMap[var] == '') {
                    minecraftArgs.remove(minecraftArgs.size() - 1)
                } else {
                    minecraftArgs.add varMap[var]
                }
            } else {
                minecraftArgs.add it
            }
        }

        return minecraftArgs
    }

    /** Extract the jars to the selected path */
    private def extractJars(List<String> paths, File extractTo) {
        Objects.requireNonNull(paths)
        Objects.requireNonNull(extractTo)
        extractTo.delete()
        extractTo.mkdirs()
        def errored = false

        paths.each {
            def file = new File(MINECRAFT_HOME, it)
            if (file.exists()) {
                new ZipFile(file).extractAll extractTo.getPath()
            } else {
                println 'no file by this name: ' + file.name
                errored = true
            }
        }

        if (errored) {
            println 'There were jars not found, if problems occur its because of this'
        }
    }

    /** Convert the json file to MinecraftVersion object */
    private MinecraftVersion makeMCVersion(File file) {
        Objects.requireNonNull(file)
        FileInputStream stream = new FileInputStream(new File(file, file.name + '.json'))
        InputStreamReader reader = new InputStreamReader(stream)
        MinecraftVersion version = GSON.fromJson reader, MinecraftVersion
        reader.close();
        return version;
    }

    /** Generate a list of ClassPaths minecraft needs */
    private ClassPaths generateLibs(MinecraftVersion object) {
        Objects.requireNonNull(object)
        ClassPaths classPaths = new ClassPaths();

        if (object.inheritsFrom != null) {
            File path = new File(new File(MINECRAFT_HOME, 'versions'), object.inheritsFrom)
            MinecraftVersion version = makeMCVersion path
            ClassPaths parent = generateLibs version
            classPaths.libs.get().addAll parent.libs.get()
            classPaths.natives.get().addAll parent.natives.get()
        }

        Collections.reverse object.libraries

        object.libraries.each {
            String[] parts = ((String) it.get('name')).split(':')
            String library = "libraries$PS${parts[0].replace('.', PS)}$PS${parts[1]}$PS${parts[2]}$PS${parts[1]}-${parts[2]}.jar"

            if (it.containsKey('natives')) {
                def platform = OS.detect().name().toLowerCase()
                def nativeName = library.substring(0, library.lastIndexOf('.jar')) + '-natives-' + platform + '.jar'
                classPaths.natives.get().addFirst nativeName
            } else {
                classPaths.libs.get().addFirst library
            }
        }

        return classPaths;
    }

    @ToString(includeNames=true)
    private class MinecraftVersion {
        String id
        String type
        String inheritsFrom
        String assets
        String minecraftArguments
        String mainClass
        List<Map<String, Object>> libraries
    }

    private class ClassPaths extends Tuples.Pair<LinkedList<String>, LinkedList<String>> {
        def libs = a
        def natives = b

        ClassPaths() { super(new LinkedList<String>(), new LinkedList<String>()) }
    }
}

// Utils for Above Script

/** Simple way of detecting the current OS of the jvm runtime */
final enum OS {
    LINUX,
    OSX,
    WINDOWS

    static OS detect() {
        def name = System.getProperty("os.name")?.toLowerCase()

        if (name.contains('linux')) return LINUX
        else if (name.contains('mac') || name.contains('osx')) return OSX
        else if (name.contains('windows')) return WINDOWS

        throw new Throwable('Could not detect os, report this issue.')
    }
}

/** A class that helps with returing tuple vales with multiple types */
final class Tuples {
    /** A class for the use of pair */
    final static class TupleValue<V> {
        private V value

        /** Get the current value, could be null */
        V get() { value }

        /** Get or else the current value */
        V getOrElse(V value) { (V) this.value ?: value }

        /** Set the current value of this tuple */
        void set(V value) { this.value = value }

        @Override
        String toString() { "TupleValue(${value})" }
    }

    /** Represents a tuple pair */
    static class Pair<A, B> {
        final TupleValue<A> a;
        final TupleValue<B> b;

        Pair(A a, B b) {
            this.a = new TupleValue<>(value: a)
            this.b = new TupleValue<>(value: b)
        }

        @Override
        String toString() { "Pair(${a?.get()}, ${b?.get()})" }
    }
}
